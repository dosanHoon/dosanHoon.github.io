---
title: React 개발기 - 혹은 삽질기
date: "2019-01-01T23:46:37.121Z"
template: "post"
draft: false
slug: "/posts/react-develop-diary"
category: "REACT"
tags:
  - "javascript"
  - "react"
description: "그동안 React 로 개발하면서 껵은 시행착오 및 삽질기"
---

# React 개발기 - 혹은 삽질기

React를 처음 접한지 2~3년 정도 됐는데 처음과 지금을 비교하면 많이도 변했다.  
늘 처음이란게 그렇듯.  
어설프고 es6 부터 시작해서 모든 것이 새로 웠다. 그래서 반면교사로 삼거나 재미삼아 변해온 과정에 대해서 간단하게 작성해보기로 했다.

## 1 단계 - React가 뭐야?

어떻게 보면 React를 접하게 된건 좋았지만, 빈부격차마냥 양극화가 심했던 당시 회사환경에서는 (뉴비 or 10년차) 표준에서 멀어지는 개발 환경이 될수 밖에 없었다. 소위 말하는 front-end 개발자도 지금 생각해보면 없었다.

webpack 은 사용하지 않았고 jsx 형식으로 작성된 react component 들을 babel-cli로 파일마다 각각 js 파일로 compile 해서 사용 했고 React 같은 라이브러리들을 CDN 으로 html에서 import 해서 global 로 적용 됐다.

또 웹서버는 GO 로 작성되어 있었고 같은 프로젝트내에 존재하다 보니 front-end 와 back-end 의 결합도가 높았고 back-end의 문제가 생겨도 front-end 개발 까지 영향을 끼치는 형태였다.

지금 생각해보면 webpack 없이 SPA가 아닌 웹을 react 로 개발한다는건 너무나도 비효율적이다.  
~~아니 사실 그 당시에도 너무 별로였음~~

### 구현

#### 1. jsx

```jsx
var NoticePop = React.createClass({
  getInitialState: function() {
    return {
      title: NOTICE
    };
  },
  getInitialProp: function() {
    return {
      title: NOTICE
    };
  },
  componentDidMount: function() {
    var state = {};
    if (this.props.title != "" && this.props.title != undefined) {
      state.title = this.props.title;
    }
    this.setState(state);
    this.refs.btn_ok.focus();
  },
  render: function() {
    return (
      /**
       * 중략
      **/
    );
  }
});
```

- React 는 html 에서 import 하기 때문에 jsx 파일내에서 import 할 필요가 없음
- 각 component 가 위와같이 global 로 선언됨
- map 등 es6 의 몇몇 function 만 사용했을뿐 es5 문법으로 작성됨(이때는 facebook 가이드도 es5...)

#### 2. html

```html
<script type="text/javascript">
  _get_react_("babel/noticepop");
  _get_react_("babel/components/lnb");
  _get_react_("babel/components/footer");
</script>
```

- 이런식으로 각 html에서 필요한 react component js 파일들을 import 하여 사용함

#### 3. js (util 성격의 script)

```javascript
  renderReactDOM: function(reactClass, elementid, param, createDiv) {
    var innerParam = null
    if (param == '' || param == undefined || param == 'undefined') {
      innerParam = null
    } else {
      innerParam = param
    }
    if (createDiv == true) {
            createDivElement(elementid);
        }
        return ReactDOM.render(React.createElement(reactClass, innerParam),  document.getElementById(elementid));

    },
```

- 일반적인 javascript 나 라이브러리등을 html 에서 import 해서 사용함.
- 이런식으로 javascript 에서 component 를 render 해서 사용하는 경우도 있었다.
- modal 팝업 등 instant 한 컴포넌트등을 이런식으로 다뤘다.
- ~~개인적으론 절대 이렇게 안한다. 언어든 라이브러리등 그 특성에 맞게 사용하고 관점은 단일화하는게 개발시도 유지보수에도 좋다.~~

### 결론

- react 이외의 것으로 작성된 프로젝트를 react 로 포팅하는 경우가 아니라면 위와같이 webpack 없이 파편화된 react 개발은 비효율적.~~(그냥 절대 하지 마라)~~
- SPA 나 client rendering 의 단점은 상대적으로 큰 buldle file 과 초기 로딩 속도 이외에는 아직도 모르겠다.
- ~~product 레벨에서 한 포인트에서의 에러가 전체에 영향을 줄수도 있다.(맞는말인지 아직 의문)~~
- back-end 개발과 front-end 개발은 분리해야 된다. 그래야 서로 편하다.
- 개발 관점은 최대한으로 줄여라
- ~~(기껏 react도입하고 다 기존의 script 에서 처리한다던가 이런걸 닭잡는데 소잡는 칼 쓴다고 하는거다.)~~

## 2 단계 es6,redux,requireJS 먹는건가요?

1단계 총체적 난국이었나면 지금부터는 과도기의 시작이다.  
서버는 JAVA 로 변경 됐고, 파편화된 js 파일들을 import 하기 위해서 requireJs 를 도입.  
전역적인 state 관리의 필요성으로 redux 도입.  
es6 전반적인 도입등 있다.

### 구현

#### jsx

```jsx
requirejs(["redux/redux", "constants/gnb", "components/popup"], function(
  Redux,
  Gnb,
  Popup
) {
  const Router = ReactRouter.Router;
  const Route = ReactRouter.Route;
  const IndexRoute = ReactRouter.IndexRoute;
  const Link = ReactRouter.Link;
  const Switch = ReactRouter.Switch;
  const browserHistory = ReactRouter.browserHistory;
  const Redirect = ReactRouter.Redirect;

  let App = ({ loginFlag }) => {
    return (
      <Router history={browserHistory}>
        <Route path="/*/*/*/inweb/" component={Container}>
          <IndexRoute component={MainBannerContainer} />
          <Route path="index" component={MainBannerContainer} />
        </Route>
      </Router>
    );
  };

  class Container extends React.Component {
    componentWillMount() {}

    componentDidMount() {
      if (AutoAlert) {
        this.props.onSETALERT({
          alertTitle: AutoAlert
        });
        this.props.onALERTOPEN();
      }
    }
    componentWillUpdate(nextProps, nextState) {
      if (this.props.location != nextProps.location) {
        this.props.onALERTCLOSE();
      }
    }
    render() {
      // 중략
    }
  }

  Popup = connect(
    mapStateToProps,
    mapDispatchToProps
  )(Popup);

  App = connect(
    mapStateToProps,
    mapDispatchToProps
  )(App);

  ReactDOM.render(
    <Provider store={REDUX_STORE}>
      <App />
    </Provider>,
    document.getElementById("mainContainer")
  );
});
```

### 결론

- requireJS 사용으로 component 나 libaray 모듈 관리가 편해졌다.
- SPA로 Redux 사용. 90% 이상 React 내에서 개발.
- 여전히 Back-end 와 Front-end 결합도 높음.

## 3 단계 React 스럽게? ~~(삽질은 그만 ㅠ ㅠ)~~

이직 후 첫 프로젝트.  
이번 프로젝트 부터는 본인의 자유도가 높아졌고 좀 더 내가 옳다는 방향 혹은 해보고 싶은 방향으로 할수 있었다.  
웹 서버는 Java spring boot 였고, API 서버들이 별도로 존재해 AJAX 를 통해서 데이터만 주고 받을뿐 웹서버의 역활이 기존 프로젝트에 비해 거의 없어졌다. Back-end 영역에서도 좀 더 모던해졌다고 할수 있겠다.

front-end 즉 React 에서는 creat-react-app 을 사용했기에 webpack-dev-server 로 좀 더 빠르게 개발 할 수 있었다. 전역 state 관리 라이브러리는 mobx 를 도입했고 SPA 로 개발하였다.

### 구성

#### 1. React Component

```jsx
//LIB
import React, { Component } from "react";
import { BrowserRouter as Router, Switch } from "react-router-dom";
import { Provider } from "mobx-react";
import Redirect from "react-router/Redirect";
//UTILS
import { getURI, UIset } from "./utils";
import { DefaultLayout } from "./containers";
import mobxStore from "./mobx";

export default class App extends Component {
  componentDidMount() {
    mobxStore.codeStore.setCode();
  }
  render() {
    const { cookieStore } = mobxStore;
    return (
      <Provider {...mobxStore}>
        <Router>
          <Switch>
            <PropsRoute
              UIset={UIset["login"]}
              exact
              path={getURI("login")}
              to="/"
              component={
                !cookieStore.checkIsLogin() ? LoginContainer : Redirect
              }
            />
          </Switch>
        </Router>
      </Provider>
    );
  }
}
```

#### 2. model

```javascript
import { Code } from "../components/index";

class Model {
  constructor(params) {
    for (const key in params) {
      if (params.hasOwnProperty(key)) {
        this[key] = params[key];
      }
    }

    this.fullName = params.firstName = params.lastName;
  }

  userName = "";
  @vaildEmail
  userEmail = "";
  fullName = "";
}

export default Model;
```

- entity 정보 모델
- state 기본값 정의 등
- validation 과 서버 DATA 가공하여 표현

#### 3. mobx

```javascript
import { observable, action } from "mobx";
import { userApis } from "../apis";

class cookieStore {
  @observable
  isLogin = false;

  @action
  setLogin = params => {
    return userApis.setLogin(params).then(() => {
      this.checkIsLogin();
    });
  };

  @action
  setLogout = () => {
    userApis.setLogout().then(() => {
      this.isLogin = false;
    });
  };
}

export default new cookieStore();
```

- 전역적인 state 관리
- api 호출

#### 4. apis

```javascript
import axiosModules from "./axiosSetting";

let userApis = {
  getUserInfo: userId => {
    return axiosModules.get(`/user/${userId}`);
  }
};

export default accountApis;
```

- api 메소드 정의

### 결론

- Back-end 와 Front-end 프로젝트로 분리로 개발이 한층 편해졌고 각자의 분야에 집중할수 있었다.
- Webpack으로 인해 model,apis 등 util성 script 들도 모듈화 하고 관리가 편해짐.
- 최대한 React 내부에서 처리할수 있도록 했고 구조화 설계를 정립했다.
- ~~(Java개발과 컨퍼런스에서 봤던게 많이 도움이 됨)~~
- Redux 에서 Mobx 로 교체한 이유는 Mobx 가 좀 더 배우기 쉽고 직관적이다.

## 4 단계 앞으로 해야 될 것들

#### 아직도 초기 로딩이 느리다.

- SSR(Server Side Rendering)
  - 초기 페이지 진입은 이거 말고는 답이 없어 보인다.
  - SEO 를 위해서도 필요할듯
- ServiceWorker
  - 브라우저내에서 캐싱해서 PWA 같이 작동이 가능해 보임.
  - webnotification 등에서 필수적으로 사용해야 할듯.
- TDD,BDD,DDD..
  - ~~먹는건가요?~~
  - ~~약파는거 같기도 하지만 front-end 구인 정보만 보면 점점 필수가 되어 가는듯.~~
- Typescript
- Code Splitting, Dynamic Import 등등등.......

~~갈길이 멀다....~~

## 후기

처음에 비해선 많이 발전한거 같아서 뿌듯하면서도 불필요한 삽집을 한거 같아 보이기도 한다.  
당신은 나보다는 좀 덜 삽질하기를 바라고 남들이 한다고 혹은 현재 유행이라고 무분별하게 도입하는것도 지양해야 되지만 현 시점에서 front-end 개발자라면 어느정도는 시류에 따를 필요가 있다고 생각한다.  
어차피 당신이 능숙해지거나 product에서 문제점을 발견할때 쯤이면 새로운게 나와있을테니 ...;;
