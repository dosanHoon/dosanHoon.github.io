{"data":{"site":{"siteMetadata":{"author":{"name":"한승훈","contacts":{"twitter":"#"}},"disqusShortname":"","subtitle":"프론트엔드 개발 기술 블로그","title":"Dosanhoon's blog","url":"https://dosanhoon.github.io/"}},"markdownRemark":{"id":"cf7fe969-9d1d-5c44-9f89-023726e74abd","html":"<p>mobx 공식 가이드에 있는 내용입니다.\n예전에 봤을때보다 내용이 추가 됐네요.\n가전 제품사면 설명서 따위 버리는 버릇으로 개발하니 삽질의 연속이라 guide 부터 다시 읽기 시작했습니다.</p>\n<h1>잘못된 위치에서 IMPORT</h1>\n<h2>Importing from wrong location</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token comment\">// wrong</span>\n  <span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mobx/lib/mobx\"</span></code></pre></div>\n<p>vscode 등에서 자동 import 기능 사용시 위와 같이 import 되는 경우가 있는데 위는 올바르지 않다.\n항상 runtime 에러를 일으키는 것은 아니니 주의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token comment\">// correct</span>\n  <span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mobx\"</span></code></pre></div>\n<h1>데코레이터 관련 문제</h1>\n<h2>Issues with decorators?</h2>\n<h3>isArray ?</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span></code></pre></div>\n<ul>\n<li>MobX 4 이하에만 적용됩니다.</li>\n</ul>\n<p>ES5에는 배열로부터 상속받는 신뢰할 수 있는 방법이 없으므로 “observable arrays”은 객체를 상속합니다. 이것은 정기적으로 라이브러리가 “observable array”을 일반 배열\n<code class=\"language-text\">(예 : lodash 또는 내장 작업과 같은 Array.concat)</code> 으로 인식 할 수 없음을 의미합니다 . 이는 <code class=\"language-text\">observable.toJS()</code>하거나 <code class=\"language-text\">observable.slice()</code>로 “observable array”을 다른 라이브러리로 전달하기 전에 간단히 해결할 수 있습니다 . 외부 라이브러리가 배열을 수정할 의도가 없으면 예상대로 완전히 작동합니다. <code class=\"language-text\">isObservableArray(observable)</code>관찰 가능한 배열인지 여부를 확인할 수 있습니다</p>\n<h3>object.someNewProp = value</h3>\n<p>(원문 : object.someNewProp = value is not picked up\nobserver가 변경사항을 감지하지 못한다로 이해하시면 됩니다.)</p>\n<ul>\n<li>MobX 4 이하에 적용됩니다.</li>\n</ul>\n<p>MobX5에서는 제한은 <code class=\"language-text\">observable() / observable.object()</code>로 생성되지 않은 클래스 인스턴스/객체에 적용됩니다 </p>\n<p>MobX observable objects는 이전에 관찰 가능하다고 선언되지 않은 속성 할당을 감지하거나 이에 반응하지 않습니다. 따라서 MobX 관찰 가능 객체는 미리 정의 된 키가있는 레코드로 작동합니다. <code class=\"language-text\">extendObservable(target, props)</code>를 통해서 observable object에 새로운 속성을 추가하는 것이 가능합니다. 그러나 <code class=\"language-text\">for .. in</code> 또는 <code class=\"language-text\">Object.keys()</code> 같은 객체 반복문에서는 자동으로 반응하지 않습니다. MobX 4 이하에서 동적으로 키를 할당하는 객체가 필요한 경우 (예 : id로 user를 저장 하는 경우) <code class=\"language-text\">observable.map</code>을 이용하여 Map을 만들거나 Object API 에서 제공하는 유틸리티 메소드를 사용 하여야 합니다.</p>\n<h2>@observer를 @observable를 렌더링하는 모든 컴포넌트에 사용하야 합니다.</h2>\n<p>@observer는 사용된 컴포넌트만 decorating 할뿐 component내부에 구성 요소에 대해서는 작동하지 않습니다.그래서 모든 component에 @observer를 decoration 해야 합니다.observer component들은 rendering을 더 효율적으로 만들어 주기때문에 걱정할 필요가 없습니다.</p>\n<h2>observables 속성을 복사하거나 컴포넌트 내부에 저장하면 안됩니다.</h2>\n<p>Observer components는 render method 내부에서 액세스되는 데이터만 추적합니다. 흔히 볼 수있는 실수가 observable property 에서 복사한 데이터와 컴포넌트에 내부에 저장한 데이터가 관측되지 않는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  @observable name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Profile</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  name\n\n  <span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Wrong</span>\n    <span class=\"token comment\">// user.name 를 한번만 복사합니다. 해당 메소드는 라이프 사이클에서 반복되지 않으므로 추후 변경되는 데이터는 업데이트 되지 않습니다.</span>\n    <span class=\"token comment\">// 이러한 할달은 중복되는 데이터를 생성합니다.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>올바른 접근법은 observable value를 로컬에 저장하지 않는 것입니다 (분명히 위의 예제는 간단하지만 부자연스러운것입니다). 또는 계산 된 프로퍼티로 정의하면됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  @observable name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Profile</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  @computed <span class=\"token keyword\">get</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// computed property 는 user.name 을 추적합니다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>렌더 콜백은 render 메소드의 일부가 아닙니다.</h2>\n<p>왜냐하면 현재 구성 요소 observer의 render 메소드 에만 정확하게 적용 되기 때문입니다 . 렌더링 콜백 또는 구성 요소를 하위 구성 요소에 전달해도 자동으로 반응하지 않습니다. 자세한 내용 은 Mobx는 무엇에 반응하는가를 참고하세요\n<a href=\"https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render\">Mobx는 무엇에 반응하는가</a></p>\n<ul>\n<li>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n<span class=\"token function-variable function\">_renderList</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//=> render call back</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">_renderList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p>}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">## 최대한 늦게 역참조해야 됩니다.\nMobX는 많은 일을 할 수 있지만 원시값을 관찰할 수는 없습니다 (오브젝트로 랩핑해야 관찰 가능 [observable.box(value)참조] (https://mobx.js.org/refguide/boxed.html)). 따라서 관찰 할 수 있는 건 값이 아니라 객체의 속성 입니다. 이는 @observer이 실제로 역참조한 값에 반응한다는 사실을 의미합니다 . \n\n\n```javascript\nReactDOM.render(&lt;Timer timerData={timerData.secondsPassed} /&gt;, document.body)</code></pre></div>\n<p>위의 예에서 Timer구성 요소는 다음과 같이 초기화 된 경우 반응 하지 않습니다 .</p>\n<p>위 예제에서는 Timer에 <code class=\"language-text\">timerData.secondsPassed</code>의 현재 값이 전달되고, 이는 불변 값입니다.(모든 원시값은 JAVASCRIPT 에서 불변합니다.). 이 값는 더 이상 변경되지 않으므로 Timer는 결코 업데이트되지 않습니다. <code class=\"language-text\">secondsPassed</code>는 변경 될 값 이므로 Component 내부에서 접근해야 합니다. 혹은 항상 관찰 가능한 속성의 소유 객체를 전달해야 합니다. 자세한 내용 은 Mobx는 무엇에 반응하는가를 참고하세요\n<a href=\"https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render\">Mobx는 무엇에 반응하는가</a></p>\n<h2>computed 값이 예상보다 자주 실행됩니다.</h2>\n<p>computed 속성이 일부 reaction(사용 중 autorun, observer등)에서 사용된게 아니라면,값이 요청될때마다 느리게 평가됩니다. (그래서 그들은 단지 보통 property로 동작합니다.) computed 속성은 종속된것이 관찰 된 경우에만 추적합니다. 이를 통해 MobX는 자주 사용되지 않는 computed 속성을 자동으로 중단 할 수 있습니다. 이 [블로그]<a href=\"https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a>)를 보거나   <a href=\"https://github.com/mobxjs/mobx/issues/356\">#356</a>의 설명을 보세요. 따라서 computed 속성이 효율적으로 보이지 않을 수 있습니다. 그러나 observer, autorun등을 사용하는 프로젝트에서 적용될 때, computed 속성은 매우 효율적입니다.</p>\n<p>computed 속성은 트랜잭션 도중 자동으로 유지됩니다. 참고 :  <a href=\"https://github.com/mobxjs/mobx/pull/452\">#452</a> 및 <a href=\"https://github.com/mobxjs/mobx/pull/489\">#489</a></p>\n<p>computed 속성을 강제로 유지하려면 <code class=\"language-text\">keepAlive: true</code>옵션을 사용할 수 있지만 메모리 누수가 발생할 수 있습니다.</p>\n<h2>항상 반응을 처리하십시오.</h2>\n<p>autorun, observe그리고 intercept의 모든 형식은 그들이 관찰 한 모든 객체가 가비지로 수집되는 경우에만 가비지 수집됩니다. 따라서 더 이상 필요하지 않을 때 메서드에서 반환 된 <code class=\"language-text\">디스 포저(disposer)</code> 함수를 사용하여 중지하는 것이 좋습니다. 일반적으로 대한 observe과 intercept는 targed 때 경우를 처리하기 위해 꼭 필요한 것은 this. 반응 autorun이 여러 가지 관측 대상을 관찰 할 수 있기 때문에 더 까다 롭습니다. 그 중 하나가 여전히 범위 내에있는 한 반응은 범위에 남아있게됩니다. 즉, 다른 모든 관측 대상이 앞으로의 재 계산을 지원하기 위해 계속 살아 있음을 의미합니다 . 따라서 더 이상 필요가 없으면 항상 반응을 처리하십시오!</p>\n<p>예:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token constant\">VAT</span> <span class=\"token operator\">=</span> <span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.20</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderLIne</span> <span class=\"token punctuation\">{</span>\n    @observable price <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    @observable amount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// this autorun will be GC-ed together with the current orderline instance</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> <span class=\"token function\">autorun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">doSomethingWith</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>amount<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// this autorun won't be GC-ed together with the current orderline instance</span>\n        <span class=\"token comment\">// since VAT keeps a reference to notify this autorun,</span>\n        <span class=\"token comment\">// which in turn keeps 'this' in scope</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> <span class=\"token function\">autorun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">doSomethingWith</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>amount <span class=\"token operator\">*</span> <span class=\"token constant\">VAT</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// So, to avoid subtle memory issues, always call..</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// When the reaction is no longer needed!</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","fields":{"tagSlugs":["/tag/javascript/","/tag/react/","/tag/mobx/"]},"frontmatter":{"date":"2019-02-20T23:46:37.121Z","description":"mobx 삽질의 연속을 줄여줄 Common pitfalls & best practices ","tags":["javascript","react","mobx"],"title":"MOBX Common pitfalls & best practices"}}},"pageContext":{"slug":"/posts/react-mobx-guide"}}