{"data":{"site":{"siteMetadata":{"author":{"name":"한승훈","contacts":{"twitter":"#"}},"disqusShortname":"","subtitle":"프론트엔드 개발 기술 블로그","title":"Dosanhoon's blog","url":"https://dosanhoon.github.io/"}},"markdownRemark":{"id":"cf7fe969-9d1d-5c44-9f89-023726e74abd","html":"<p>mobx 공식 가이드에 있는 내용입니다.\n예전에 봤을때보다 내용이 추가 됐네요.\n가전 제품사면 설명서 따위 버리는 버릇으로 개발하니 삽질의 연속이라 guide 부터 다시 읽기 시작했습니다.</p>\n<h1>잘못된 위치에서 IMPORT</h1>\n<h2>Importing from wrong location</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token comment\">// wrong</span>\n  <span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mobx/lib/mobx\"</span></code></pre></div>\n<p>vscode 등에서 자동 import 기능 사용시 위와 같이 import 되는 경우가 있는데 위는 올바르지 않다.\n항상 runtime 에러를 일으키는 것은 아니니 주의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token comment\">// correct</span>\n  <span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> observable <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mobx\"</span></code></pre></div>\n<h1>데코레이터 관련 문제</h1>\n<h2>Issues with decorators?</h2>\n<h3>isArray ?</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token function\">observable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token boolean\">false</span></code></pre></div>\n<ul>\n<li>MobX 4 이하에만 적용됩니다.</li>\n</ul>\n<p>ES5에는 배열로부터 상속받는 신뢰할 수 있는 방법이 없으므로 “observable arrays”은 객체를 상속합니다. 이것은 정기적으로 라이브러리가 “observable array”을 일반 배열\n<code class=\"language-text\">(예 : lodash 또는 내장 작업과 같은 Array.concat)</code> 으로 인식 할 수 없음을 의미합니다 . 이는 <code class=\"language-text\">observable.toJS()</code>하거나 <code class=\"language-text\">observable.slice()</code>로 “observable array”을 다른 라이브러리로 전달하기 전에 간단히 해결할 수 있습니다 . 외부 라이브러리가 배열을 수정할 의도가 없으면 예상대로 완전히 작동합니다. <code class=\"language-text\">isObservableArray(observable)</code>관찰 가능한 배열인지 여부를 확인할 수 있습니다</p>\n<h3>object.someNewProp = value</h3>\n<p>(원문 : object.someNewProp = value is not picked up\nobserver가 변경사항을 감지하지 못한다로 이해하시면 됩니다.)</p>\n<ul>\n<li>MobX 4 이하에 적용됩니다.</li>\n</ul>\n<p>MobX5에서는 제한은 <code class=\"language-text\">observable() / observable.object()</code>로 생성되지 않은 클래스 인스턴스/객체에 적용됩니다 </p>\n<p>MobX observable objects는 이전에 관찰 가능하다고 선언되지 않은 속성 할당을 감지하거나 이에 반응하지 않습니다. 따라서 MobX 관찰 가능 객체는 미리 정의 된 키가있는 레코드로 작동합니다. <code class=\"language-text\">extendObservable(target, props)</code>를 통해서 observable object에 새로운 속성을 추가하는 것이 가능합니다. 그러나 <code class=\"language-text\">for .. in</code> 또는 <code class=\"language-text\">Object.keys()</code> 같은 객체 반복문에서는 자동으로 반응하지 않습니다. MobX 4 이하에서 동적으로 키를 할당하는 객체가 필요한 경우 (예 : id로 user를 저장 하는 경우) <code class=\"language-text\">observable.map</code>을 이용하여 Map을 만들거나 Object API 에서 제공하는 유틸리티 메소드를 사용 하여야 합니다.</p>\n<h2>@observer를 @observable를 렌더링하는 모든 컴포넌트에 사용하야 합니다.</h2>\n<p>@observer는 사용된 컴포넌트만 decorating 할뿐 component내부에 구성 요소에 대해서는 작동하지 않습니다.그래서 모든 component에 @observer를 decoration 해야 합니다.observer component들은 rendering을 더 효율적으로 만들어 주기때문에 걱정할 필요가 없습니다.</p>\n<h2>observables 속성을 복사하거나 컴포넌트 내부에 저장하면 안됩니다.</h2>\n<p>Observer components는 render method 내부에서 액세스되는 데이터만 추적합니다. 흔히 볼 수있는 실수가 observable property 에서 복사한 데이터와 컴포넌트에 내부에 저장한 데이터가 관측되지 않는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  @observable name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Profile</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  name\n\n  <span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Wrong</span>\n    <span class=\"token comment\">// user.name 를 한번만 복사합니다. 해당 메소드는 라이프 사이클에서 반복되지 않으므로 추후 변경되는 데이터는 업데이트 되지 않습니다.</span>\n    <span class=\"token comment\">// 이러한 할달은 중복되는 데이터를 생성합니다.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>올바른 접근법은 observable value를 로컬에 저장하지 않는 것입니다 (분명히 위의 예제는 간단하지만 부자연스러운것입니다). 또는 계산 된 프로퍼티로 정의하면됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  @observable name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Profile</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  @computed <span class=\"token keyword\">get</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// computed property 는 user.name 을 추적합니다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>name\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>렌더 콜백은 render 메소드의 일부 가 아닙니다.</h2>\n<p>왜냐하면 현재 구성 요소 observer의 render 메소드 에만 정확하게 적용 되기 때문입니다 . 렌더링 콜백 또는 구성 요소를 하위 구성 요소에 전달해도 자동으로 반응하지 않습니다. 자세한 내용 은 Mobx는 무엇에 반응하는가를 참고하세요\n<a href=\"https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render\">Mobx는 무엇에 반응하는가</a></p>","fields":{"tagSlugs":["/tag/javascript/","/tag/react/","/tag/mobx/"]},"frontmatter":{"date":"2019-02-20T23:46:37.121Z","description":"mobx 삽질의 연속을 줄여줄 Common pitfalls & best practices ","tags":["javascript","react","mobx"],"title":"MOBX Common pitfalls & best practices"}}},"pageContext":{"slug":"/posts/react-mobx-guide"}}