<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-post-template-js.879716efda1fff17365c.css">.Layout-module--layout--EpQHE{max-width:66.875rem;margin-left:auto;margin-right:auto}.Layout-module--layout--EpQHE:before{content:"";display:table}.Layout-module--layout--EpQHE:after{content:"";display:table;clear:both}.Author-module--author--2kf8a{border-top:1px solid #e6e6e6;max-width:40rem;padding-top:1.25rem;line-height:1.625rem;margin-top:1.625rem;margin-bottom:3.25rem}.Author-module--author__bio-twitter--MufFK{display:block;text-decoration:underline}@media screen and (min-width:685px){.Author-module--author--2kf8a{margin-left:auto;margin-right:auto}}.Content-module--content--1tfQQ{max-width:59.0625rem;padding:0 .9375rem;margin:0 auto}.Content-module--content__title--1qFLI{font-size:2rem;max-width:40rem;font-weight:600;text-align:center;line-height:2.68125rem;margin:1.625rem auto 0}.Content-module--content__body--2bfha figure{margin-bottom:1.625rem}.Content-module--content__body--2bfha figure blockquote{font-style:italic;text-align:center;margin-top:0;padding:1.625rem 0}.Content-module--content__body--2bfha figure blockquote p{max-width:40rem;font-size:1.6817rem;margin-top:0;margin-bottom:1.625rem;line-height:2.4375rem}.Content-module--content__body--2bfha a{text-decoration:underline}.Content-module--content__body--2bfha .Content-module--gatsby-highlight--2G8B5{max-width:40rem;margin-left:.9375rem;margin-right:.9375rem;margin-bottom:1.625rem}.Content-module--content__body--2bfha :not(div){width:100%;max-width:40rem;margin-left:auto;margin-right:auto}@media screen and (min-width:685px){.Content-module--content__body--2bfha .Content-module--gatsby-highlight--2G8B5{margin-left:auto;margin-right:auto}}@media screen and (min-width:960px){.Content-module--content--1tfQQ{padding:0}.Content-module--content__title--1qFLI{font-size:3rem;line-height:3.65625rem;margin-top:3.65625rem;margin-bottom:2.4375rem}.Content-module--content__body--2bfha,.Content-module--content__body--2bfha p{font-size:1.125rem;line-height:1.82813rem;margin-bottom:1.82813rem}}.Meta-module--meta__date--3FNDv{font-style:italic}.Tags-module--tags--1oNz4{margin-bottom:.8125rem}.Tags-module--tags__list--2UTD-{list-style:none;margin:0 -.625rem;padding:0}.Tags-module--tags__list-item--b7tap{display:inline-block;margin:.625rem .3125rem}.Tags-module--tags__list-item-link--1hQL0{display:inline-block;height:35px;padding:0 1.5rem;line-height:2.1875rem;border:1px solid #e6e6e6;text-decoration:none;border-radius:1.25rem;color:#222}.Tags-module--tags__list-item-link--1hQL0:focus,.Tags-module--tags__list-item-link--1hQL0:hover{color:#5d93ff}.Post-module--post__comments--2T8dL,.Post-module--post__footer--1BvmJ{max-width:40rem;margin:0 auto;padding:0 .9375rem}.Post-module--post__home-button--3zx_9{display:block;max-width:5.625rem;height:35px;padding:0 1.5rem;line-height:2.1875rem;text-align:center;color:#222;border:1px solid #e6e6e6;border-radius:1.25rem;font-size:1rem;font-weight:400;margin-left:auto;margin-right:auto;margin-top:1.625rem}.Post-module--post__home-button--3zx_9:focus,.Post-module--post__home-button--3zx_9:hover{color:#5d93ff}@media screen and (min-width:960px){.Post-module--post__comments--2T8dL,.Post-module--post__footer--1BvmJ{padding:0}.Post-module--post__home-button--3zx_9{position:fixed;max-width:auto;margin:0;top:30px;left:30px}}</style><style data-href="/app.2571edf2fab0aa04515d.css">code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}html{font-size:100}body{color:#222;line-height:1.625;font-size:1rem;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}body,h1,h2,h3,h4,h5,h6{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif}h1,h2,h3,h4,h5,h6{font-weight:600}h1{font-size:2.5rem;line-height:3.25rem;margin-top:6.5rem;margin-bottom:1.625rem}h2{font-size:1.6875rem;line-height:2.4375rem}h2,h3{margin-top:3.25rem;margin-bottom:.8125rem}h3{font-size:1.375rem;line-height:1.625rem}h4{font-size:1.2rem;margin-top:2.4375rem}h4,h5{line-height:1.625rem;margin-bottom:.8125rem}h5,h6{font-size:1rem;margin-top:4.0625rem}h6{line-height:1.625rem;margin-bottom:.8125rem}img{max-width:100%;margin:inherit auto}hr,img{border:0;display:block}hr{color:#222;height:26px;margin:3.25rem auto;background-size:100% 26px;background-image:linear-gradient(180deg,transparent 1px,transparent 11px,#222 0,#222 15px,transparent 0,transparent 26px);width:6.25rem}a{color:#5d93ff;text-decoration:none}a:active,a:focus,a:hover{color:#f7a046}b,strong{font-weight:600}ul{list-style:square;margin-bottom:1.625rem}ul li{padding:0 .3125rem;margin-bottom:.625rem}p{line-height:1.625rem;margin-bottom:1.625rem}blockquote{padding:0;font-style:italic;text-align:center}figure{display:block;width:100%;height:auto}figcaption{line-height:1.21875rem;margin-top:.40625rem;color:#222;font-size:.875rem;font-style:italic;margin-bottom:0;text-align:center}@media screen and (min-width:685px){figure.float-left,figure.float-right{max-width:19.375rem;padding:0 1.625rem}.float-right{float:right}.float-left{float:left}}</style><meta name="generator" content="Gatsby 2.0.111"/><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>            
              (adsbygoogle = window.adsbygoogle || []).push({
                google_ad_client: "ca-pub-9797082012043325",
                enable_page_level_ads: true
              });
          </script><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#F7A046"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">MOBX Common pitfalls &amp; best practices - Dosanhoon&#x27;s blog</title><meta data-react-helmet="true" name="description" content="mobx 삽질의 연속을 줄여줄 Common pitfalls &amp; best practices "/><meta data-react-helmet="true" name="google-site-verification" content="lpAHpWtJQjy1Lhv6UTgNM4hzCePecRn5ixX9OKRalZg"/><meta data-react-helmet="true" name="naver-site-verification" content="c5a3100ee74684026d3150177a533e4dbe147d6d"/><link as="script" rel="preload" href="/webpack-runtime-7717693bec7607176d1f.js"/><link as="script" rel="preload" href="/app-6b28bfcd840f439adc93.js"/><link as="script" rel="preload" href="/0-083dcea65c4ece254e2d.js"/><link as="script" rel="preload" href="/1-2c86ec36555985dcee30.js"/><link as="script" rel="preload" href="/component---src-templates-post-template-js-1e9e4156fcb8e0bc683c.js"/><link as="fetch" rel="preload" href="/static/d/552/path---posts-react-mobx-guide-2-e-3-a60-3UDoIJmbdK1mtAgKYlJ0nVe0Ew.json" crossOrigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div class="Layout-module--layout--EpQHE"><div><a class="Post-module--post__home-button--3zx_9" href="/">All Articles</a><div><div class="Content-module--content--1tfQQ"><h1 class="Content-module--content__title--1qFLI">MOBX Common pitfalls &amp; best practices</h1><div class="Content-module--content__body--2bfha"><p>mobx 공식 가이드에 있는 내용입니다.
예전에 봤을때보다 내용이 추가 됐네요.
가전 제품사면 설명서 따위 버리는 버릇으로 개발하니 삽질의 연속이라 guide 부터 다시 읽기 시작했습니다.</p>
<h1>잘못된 위치에서 IMPORT</h1>
<h2>Importing from wrong location</h2>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">  <span class="token comment">// wrong</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"mobx/lib/mobx"</span></code></pre></div>
<p>vscode 등에서 자동 import 기능 사용시 위와 같이 import 되는 경우가 있는데 위는 올바르지 않다.
항상 runtime 에러를 일으키는 것은 아니니 주의하자.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">  <span class="token comment">// correct</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"mobx"</span></code></pre></div>
<h1>데코레이터 관련 문제</h1>
<h2>Issues with decorators?</h2>
<h3>isArray ?</h3>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">  Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">false</span></code></pre></div>
<ul>
<li>MobX 4 이하에만 적용됩니다.</li>
</ul>
<p>ES5에는 배열로부터 상속받는 신뢰할 수 있는 방법이 없으므로 “observable arrays”은 객체를 상속합니다. 이것은 정기적으로 라이브러리가 “observable array”을 일반 배열
<code class="language-text">(예 : lodash 또는 내장 작업과 같은 Array.concat)</code> 으로 인식 할 수 없음을 의미합니다 . 이는 <code class="language-text">observable.toJS()</code>하거나 <code class="language-text">observable.slice()</code>로 “observable array”을 다른 라이브러리로 전달하기 전에 간단히 해결할 수 있습니다 . 외부 라이브러리가 배열을 수정할 의도가 없으면 예상대로 완전히 작동합니다. <code class="language-text">isObservableArray(observable)</code>관찰 가능한 배열인지 여부를 확인할 수 있습니다</p>
<h3>object.someNewProp = value</h3>
<p>(원문 : object.someNewProp = value is not picked up
observer가 변경사항을 감지하지 못한다로 이해하시면 됩니다.)</p>
<ul>
<li>MobX 4 이하에 적용됩니다.</li>
</ul>
<p>MobX5에서는 제한은 <code class="language-text">observable() / observable.object()</code>로 생성되지 않은 클래스 인스턴스/객체에 적용됩니다 </p>
<p>MobX observable objects는 이전에 관찰 가능하다고 선언되지 않은 속성 할당을 감지하거나 이에 반응하지 않습니다. 따라서 MobX 관찰 가능 객체는 미리 정의 된 키가있는 레코드로 작동합니다. <code class="language-text">extendObservable(target, props)</code>를 통해서 observable object에 새로운 속성을 추가하는 것이 가능합니다. 그러나 <code class="language-text">for .. in</code> 또는 <code class="language-text">Object.keys()</code> 같은 객체 반복문에서는 자동으로 반응하지 않습니다. MobX 4 이하에서 동적으로 키를 할당하는 객체가 필요한 경우 (예 : id로 user를 저장 하는 경우) <code class="language-text">observable.map</code>을 이용하여 Map을 만들거나 Object API 에서 제공하는 유틸리티 메소드를 사용 하여야 합니다.</p>
<h2>@observer를 @observable를 렌더링하는 모든 컴포넌트에 사용하야 합니다.</h2>
<p>@observer는 사용된 컴포넌트만 decorating 할뿐 component내부에 구성 요소에 대해서는 작동하지 않습니다.그래서 모든 component에 @observer를 decoration 해야 합니다.observer component들은 rendering을 더 효율적으로 만들어 주기때문에 걱정할 필요가 없습니다.</p>
<h2>observables 속성을 복사하거나 컴포넌트 내부에 저장하면 안됩니다.</h2>
<p>Observer components는 render method 내부에서 액세스되는 데이터만 추적합니다. 흔히 볼 수있는 실수가 observable property 에서 복사한 데이터와 컴포넌트에 내부에 저장한 데이터가 관측되지 않는 것입니다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  @observable name
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Profile</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  name

  <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Wrong</span>
    <span class="token comment">// user.name 를 한번만 복사합니다. 해당 메소드는 라이프 사이클에서 반복되지 않으므로 추후 변경되는 데이터는 업데이트 되지 않습니다.</span>
    <span class="token comment">// 이러한 할달은 중복되는 데이터를 생성합니다.</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>올바른 접근법은 observable value를 로컬에 저장하지 않는 것입니다 (분명히 위의 예제는 간단하지만 부자연스러운것입니다). 또는 계산 된 프로퍼티로 정의하면됩니다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  @observable name
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Profile</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  @computed <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// computed property 는 user.name 을 추적합니다.</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2>렌더 콜백은 render 메소드의 일부가 아닙니다.</h2>
<p>왜냐하면 현재 구성 요소 observer의 render 메소드 에만 정확하게 적용 되기 때문입니다 . 렌더링 콜백 또는 구성 요소를 하위 구성 요소에 전달해도 자동으로 반응하지 않습니다. 자세한 내용 은 Mobx는 무엇에 반응하는가를 참고하세요
<a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render">Mobx는 무엇에 반응하는가</a></p>
<ul>
<li>
<p>예시)</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
<span class="token function-variable function">_renderList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">//=> render call back</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_renderList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
</li>
</ul>
<p>}</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">## 최대한 늦게 역참조해야 됩니다.
MobX는 많은 일을 할 수 있지만 원시값을 관찰할 수는 없습니다 (오브젝트로 랩핑해야 관찰 가능 [observable.box(value)참조] (https://mobx.js.org/refguide/boxed.html)). 따라서 관찰 할 수 있는 건 값이 아니라 객체의 속성 입니다. 이는 @observer이 실제로 역참조한 값에 반응한다는 사실을 의미합니다 . 


```javascript
ReactDOM.render(&lt;Timer timerData={timerData.secondsPassed} /&gt;, document.body)</code></pre></div>
<p>위의 예에서 Timer구성 요소는 다음과 같이 초기화 된 경우 반응 하지 않습니다 .</p>
<p>위 예제에서는 Timer에 <code class="language-text">timerData.secondsPassed</code>의 현재 값이 전달되고, 이는 불변 값입니다.(모든 원시값은 JAVASCRIPT 에서 불변합니다.). 이 값는 더 이상 변경되지 않으므로 Timer는 결코 업데이트되지 않습니다. <code class="language-text">secondsPassed</code>는 변경 될 값 이므로 Component 내부에서 접근해야 합니다. 혹은 항상 관찰 가능한 속성의 소유 객체를 전달해야 합니다. 자세한 내용 은 Mobx는 무엇에 반응하는가를 참고하세요
<a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render">Mobx는 무엇에 반응하는가</a></p>
<h2>computed 값이 예상보다 자주 실행됩니다.</h2>
<p>computed 속성이 일부 reaction(사용 중 autorun, observer등)에서 사용된게 아니라면,값이 요청될때마다 느리게 평가됩니다. (그래서 그들은 단지 보통 property로 동작합니다.) computed 속성은 종속된것이 관찰 된 경우에만 추적합니다. 이를 통해 MobX는 자주 사용되지 않는 computed 속성을 자동으로 중단 할 수 있습니다. 이 [블로그]<a href="https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a>)를 보거나   <a href="https://github.com/mobxjs/mobx/issues/356">#356</a>의 설명을 보세요. 따라서 computed 속성이 효율적으로 보이지 않을 수 있습니다. 그러나 observer, autorun등을 사용하는 프로젝트에서 적용될 때, computed 속성은 매우 효율적입니다.</p>
<p>computed 속성은 트랜잭션 도중 자동으로 유지됩니다. 참고 :  <a href="https://github.com/mobxjs/mobx/pull/452">#452</a> 및 <a href="https://github.com/mobxjs/mobx/pull/489">#489</a></p>
<p>computed 속성을 강제로 유지하려면 <code class="language-text">keepAlive: true</code>옵션을 사용할 수 있지만 메모리 누수가 발생할 수 있습니다.</p>
<h2>항상 reactions을 처리하십시오.</h2>
<p>autorun, observe그리고 intercept의 모든 형식은 그들이 관찰 한 모든 객체가 가비지로 수집되는 경우에만 가비지 수집됩니다. 따라서 더 이상 필요하지 않을 때 메서드에서 반환 된 <code class="language-text">디스 포저(disposer)</code> 함수를 사용하여 중지하는 것이 좋습니다. 일반적으로 대한 observe과 intercept는 thisdp targed돤 경우를 dispose가 필요하지 않습니다. autorun이 여러 가지 관측 대상을 관찰 할 수 있기 때문에 더욱 까다롭습니다. observable 객체가 하나라도 scope에 남아있다면 다른 모든 observable객체가 남아있습니다. 그래서 observable객체가 더 이상 필요하지 않을떄는 항상 dispose 해주는 것이 좋습니다.</p>
<p>예:</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token constant">VAT</span> <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token number">1.20</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">OrderLIne</span> <span class="token punctuation">{</span>
    @observable price <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    @observable amount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// this autorun will be GC-ed together with the current orderline instance</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> <span class="token function">autorun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
            <span class="token function">doSomethingWith</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>amount<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// this autorun won't be GC-ed together with the current orderline instance</span>
        <span class="token comment">// since VAT keeps a reference to notify this autorun,</span>
        <span class="token comment">// which in turn keeps 'this' in scope</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> <span class="token function">autorun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
            <span class="token function">doSomethingWith</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>amount <span class="token operator">*</span> <span class="token constant">VAT</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// So, to avoid subtle memory issues, always call..</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// When the reaction is no longer needed!</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h3>React Component에서 @observable를 사용할 때 버그가 있습니다.</h3>
<p>react-hot-loader 를 사용할떄 데코레이터를 지원하지 않는 Uncaught TypeError: Cannot assign to read only property ‘__mobxLazyInitializers’ of object에러가 발생합니다 . 사용하기 위해선 @observabl대신에 componentWillMount 에 extendObservable를 사용해야 합니다. 또는 react-hot-loader “^3.0.0-beta.2”이상으로 업그레이드 해야 합니다.</p>
<h2>React Component의 표시 이름이 설정되지 않았습니다.</h2>
<p>export const MyComponent = observer((props => <div>hi</div>))를 사용하는 경우 devtools에 표시 이름이 표시되지 않습니다.
다음과 같은 방법을 사용하여 이를 해결할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 1 (set displayName explicitly)</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props <span class="token operator">=></span> <span class="token operator">&lt;</span>div<span class="token operator">></span>hi<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
myComponent<span class="token punctuation">.</span>displayName <span class="token operator">=</span> <span class="token string">"MyComponent"</span>

<span class="token comment">// 2 (MobX infers component name from function name)</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>hi<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 3 (transpiler will infer component name from variable name)</span>
<span class="token keyword">const</span> _MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props <span class="token operator">=></span> <span class="token operator">&lt;</span>div<span class="token operator">></span>hi<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span>_MyComponent<span class="token punctuation">)</span>

<span class="token comment">// 4 (with default export)</span>
<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props <span class="token operator">=></span> <span class="token operator">&lt;</span>div<span class="token operator">></span>hi<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">observer</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span></code></pre></div>
<p><a href="http://mobxjs.github.io/mobx/best/stateless-HMR.html">http://mobxjs.github.io/mobx/best/stateless-HMR.html</a> 또는 <a href="https://github.com/mobxjs/mobx/issues/141#issuecomment-228457886">#141</a> # 141을 참고하십시오 .</p>
<h2>Oservable Array의 propType은 object입니다.</h2>
<p>Oservable Array는 실제로는 객체이므로 <code class="language-text">propTypes.object</code>를 준수합니다. Observable 객체에 대해서는 <code class="language-text">mobx-react</code>가 명시적으로 PropTypes를 제공합니다 .</p>
<h2>React 네이티브에서 ListView 렌더링하기</h2>
<p>ListView.DataSourcein React 네이티브는 실제 배열을 기대합니다. 관찰 가능한 배열은 실제로는 객체이므로 .slice()로 전달하기 전에 먼저 배열로 변환하십시오.
또한 ListView.DataSource자체를 Store로 이동하여 @computed로 자동 갱신 할 수 있으며, 이 단계는 component 레벨에서도 수행 할 수 있습니다.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ListStore</span> <span class="token punctuation">{</span>
  @observable list <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">'Hello World!'</span><span class="token punctuation">,</span>
    <span class="token string">'Hello React Native!'</span><span class="token punctuation">,</span>
    <span class="token string">'Hello MobX!'</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>

  ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListView<span class="token punctuation">.</span>DataSource</span><span class="token punctuation">(</span><span class="token punctuation">{</span> rowHasChanged<span class="token punctuation">:</span> <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span> <span class="token operator">=></span> r1 <span class="token operator">!==</span> r2 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  @computed <span class="token keyword">get</span> <span class="token function">dataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ds<span class="token punctuation">.</span><span class="token function">cloneWithRows</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> listStore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

@observer <span class="token keyword">class</span> <span class="token class-name">List</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ListView
        dataSource<span class="token operator">=</span><span class="token punctuation">{</span>listStore<span class="token punctuation">.</span>dataSource<span class="token punctuation">}</span>
        renderRow<span class="token operator">=</span><span class="token punctuation">{</span>row <span class="token operator">=></span> <span class="token operator">&lt;</span>Text<span class="token operator">></span><span class="token punctuation">{</span>row<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>Text<span class="token operator">></span><span class="token punctuation">}</span>
        enableEmptySections<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>자세한 내용은 <a href="https://github.com/mobxjs/mobx/issues/476">#476</a>을 참조하십시오.</p>
<h2>propType을 선언하면 dev 모드에서 불필요한 렌더링이 발생할 수 있습니다.</h2>
<p>참조 : <a href="https://github.com/mobxjs/mobx-react/issues/56">https://github.com/mobxjs/mobx-react/issues/56</a></p>
<h2>Observer React Component의 (일부) React lifecycle method에 action.bound를 decorate 하지 않아야 합니다.</h2>
<p>위에서 언급했듯이, 관찰 가능한 데이터를 사용하는 모든 React Component는 <code class="language-text">@observer</code>로 decorate 되어야 합니다. 또한 React Component내부 함수에서 <code class="language-text">observable</code> 데이터를 수정하려는 경우 해당 함수는 <code class="language-text">@action</code>로 표시되어야합니다.
또한 this가 <code class="language-text">class component</code>의 인스턴스를 참조하려면 @action.bound 사용해야합니다. 다음 클래스를 참고하세요.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  @observable disposer <span class="token comment">// &lt;--- this value is disposed in addActed</span>

  @action<span class="token punctuation">.</span>bound
  <span class="token function">addActed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  @action<span class="token punctuation">.</span>bound
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>disposer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">//&lt;-- details don't matter</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>마운트 된 ExampleComponent에서 addActed()를 호출하면, 디스 포저가 호출됩니다.
반면에 다음을 고려하세요.</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  @observable disposer <span class="token comment">// &lt;--- this value is disposed in addActed</span>

  @action<span class="token punctuation">.</span>bound
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  @action<span class="token punctuation">.</span>bound
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>disposer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">//&lt;-- details don't matter</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이 경우는 disposer가 결코 호출 되지 않을 것입니다! 그 이유는 observer되는 ExampleComponentan을 만들기위한 mixin에 있습니다. componentWillUnmount함수가 예기치 않은 React.Component 인스턴스로 this를 변경합니다.
이 문제를 해결하려면 componentWillUnmount()다음과 같이 선언하십시오 .</p>
<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">runInAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div></div></div></div><div class="Post-module--post__footer--1BvmJ"><div><p class="Meta-module--meta__date--3FNDv">Published <!-- -->21 Feb 2019</p></div><div class="Tags-module--tags--1oNz4"><ul class="Tags-module--tags__list--2UTD-"><li class="Tags-module--tags__list-item--b7tap"><a class="Tags-module--tags__list-item-link--1hQL0" href="/tag/javascript/">javascript</a></li><li class="Tags-module--tags__list-item--b7tap"><a class="Tags-module--tags__list-item-link--1hQL0" href="/tag/react/">react</a></li><li class="Tags-module--tags__list-item--b7tap"><a class="Tags-module--tags__list-item-link--1hQL0" href="/tag/mobx/">mobx</a></li></ul></div><div class="Author-module--author--2kf8a"><p>프론트엔드 개발 기술 블로그<a class="Author-module--author__bio-twitter--MufFK" href="https://www.twitter.com/#" rel="noopener noreferrer" target="_blank"><strong>한승훈</strong> on Twitter</a></p></div></div><div class="Post-module--post__comments--2T8dL"></div></div></div></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-133683593-1', 'auto', {});
      
      
      
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-post-template-js","jsonName":"posts-react-mobx-guide-2e3","path":"/posts/react-mobx-guide"};window.dataPath="552/path---posts-react-mobx-guide-2-e-3-a60-3UDoIJmbdK1mtAgKYlJ0nVe0Ew";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app.2571edf2fab0aa04515d.css","/app-6b28bfcd840f439adc93.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-4785a2e02a4b1ec8e210.js"],"component---src-templates-not-found-template-js":["/component---src-templates-not-found-template-js.67aa43aa5136c7996ebb.css","/component---src-templates-not-found-template-js-cfd4a4d44bfcb9a78748.js"],"component---src-templates-tags-list-template-js":["/component---src-templates-tags-list-template-js-ade323a43a22508540db.js"],"component---src-templates-categories-list-template-js":["/component---src-templates-categories-list-template-js-d28cc8d74f05acf95542.js"],"component---src-templates-post-template-js":["/component---src-templates-post-template-js.879716efda1fff17365c.css","/component---src-templates-post-template-js-1e9e4156fcb8e0bc683c.js"],"component---src-templates-page-template-js":["/component---src-templates-page-template-js.5528ec72191d77d0eb08.css","/component---src-templates-page-template-js-3bcc1472fbc7ad727b20.js"],"component---src-templates-tag-template-js":["/component---src-templates-tag-template-js-4ddd2c42e255ac6a5600.js"],"component---src-templates-category-template-js":["/component---src-templates-category-template-js-20d6cd75523fe91190a4.js"],"component---src-templates-index-template-js":["/component---src-templates-index-template-js-d4917ca15fd9f376d09c.js"],"pages-manifest":["/pages-manifest-585e3c899123b3d0feb7.js"]};/*]]>*/</script><script src="/component---src-templates-post-template-js-1e9e4156fcb8e0bc683c.js" async=""></script><script src="/1-2c86ec36555985dcee30.js" async=""></script><script src="/0-083dcea65c4ece254e2d.js" async=""></script><script src="/app-6b28bfcd840f439adc93.js" async=""></script><script src="/webpack-runtime-7717693bec7607176d1f.js" async=""></script></body></html>